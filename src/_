# 1 "proc.cpp"
# 1 "<command-line>"
# 1 "proc.cpp"

# 1 "../include/proc.h" 1
# 10 "../include/proc.h"
const int MAX_BIN_SIZE = 100;
const int MAX_CMDS_AMOUNT = 50;
const int PROC_VERSION = 2;
const int REG_AMOUNT = 4;
const int RAM_SIZE = 100;



struct Processor
{
    int version;
    int cmds_amount;
    const char* cmds;

    int Regs[4];

    int* Ram;
};




void StartProc ();

void ParseBinFile (Processor* self, char* code);

void Execute (Processor* Stream);

void ProcessPush (Stack* self, const char* code, int ip, Processor* Stream);

void ProcessPop (Stack* self, const char* code, int ip, Processor* Stream);

void ProcessCommand (Stack* self, const char* code, int* ip, Processor* Stream);

void ProcCtor (Processor* self);

void ProcDtor (Processor* self);

int* GetArg (int cmd, const char* code, Processor* Stream);
# 3 "proc.cpp" 2

void StartProc ()
{
    FILE* CmdFile = get_file ("../data/cmds.bin", "rb");
    char* buffer = (char*) calloc (sizeof (int), MAX_BIN_SIZE);
    fread (buffer, sizeof (int), MAX_CMDS_AMOUNT, CmdFile);

    Processor Stream = {};
    ProcCtor (&Stream);

    ParseBinFile (&Stream, buffer);
    if (Stream.version != PROC_VERSION) printf ("Wrong bin file!");
    Execute (&Stream);

    FREE(buffer);
    fclose (CmdFile);
    ProcDtor (&Stream);
}


void ParseBinFile (Processor* self, char* code)
{
    self->version = code[VERSION_INDX];
    self->cmds_amount = code[CMD_AMT_INDX];

    if (code[SG_INDX1] != 'C' || code[SG_INDX2] != 'U' || code[SG_INDX3] != 'M') printf ("Wrong signature!\n");

    printf ("Cur Version: %d, Curr Cmd Amount: %d \n\n", code[VERSION_INDX], code[CMD_AMT_INDX]);

    self->cmds = code;

}


void Execute (Processor* Stream)
{
    Stack MainStack = {};
    StackCtor (&MainStack, 2);

    for (int ip = WORK_DATA_LEN; ip < Stream->cmds_amount; ip++)
    {
        ProcessCommand (&MainStack, Stream->cmds + ip, &ip, Stream);
    }

    StackDtor (&MainStack);
}


void ProcessCommand (Stack* self, const char* code, int* ip, Processor* Stream)
{
# 62 "proc.cpp"
    switch (*code & CMD_BITMASK)
    {
# 1 "../include/cmds.h" 1
case HLT: { printf ("End of commands\n"); } break;





case PUSH: { ProcessPush (self, code, *ip, Stream); (*ip) += INT_OFFSET; } break;





case MLT: { StackPush (self, StackPop (self) + StackPop (self)); } break;




case ADD: { printf ("Adding\n"); StackPush (self, StackPop(self) + StackPop(self)); } break;





case SUB: { StackPush (self, -StackPop (self) + StackPop (self)); } break;




case DIV: { StackPush (self, StackPop(self) / StackPop(self)); } break;




case POP: { ProcessPop (self, code, *ip, Stream); printf ("Popping.\n"); (*ip) += INT_OFFSET; } break;






case OUT: { printf ("Stack out: %d\n", StackPop (self)); } break;





case DMP: {} break;

case JMP: { *ip = *(int*)(code + 1) - 1; printf ("Jumping to %d\n", *ip); } break;





case JB: { if (StackPop(self) < StackPop(self)) { *ip = *(int*)(code + 1) - 1; printf ("Jumping to %d\n", *ip); } else { *ip += INT_OFFSET; } } break;
# 68 "../include/cmds.h"
case JBE: { if (StackPop(self) <= StackPop(self)) { *ip = *(int*)(code + 1) - 1; printf ("Jumping to %d\n", *ip); } else { *ip += INT_OFFSET; } } break;
# 81 "../include/cmds.h"
case JA: { if (StackPop(self) > StackPop(self)) { *ip = *(int*)(code + 1) - 1; printf ("Jumping to %d\n", *ip); } else { *ip += INT_OFFSET; } } break;
# 93 "../include/cmds.h"
case JAE: { if (StackPop(self) >= StackPop(self)) { *ip = *(int*)(code + 1) - 1; printf ("Jumping to %d\n", *ip); } else { *ip += INT_OFFSET; } } break;
# 106 "../include/cmds.h"
case JE: { if (StackPop(self) == StackPop(self)) { *ip = *(int*)(code + 1) - 1; printf ("Jumping to %d\n", *ip); } else { *ip += INT_OFFSET; } } break;
# 119 "../include/cmds.h"
case JNE: { if (StackPop(self) != StackPop(self)) { *ip = *(int*)(code + 1) - 1; printf ("Jumping to %d\n", *ip); } else { *ip += INT_OFFSET; } } break;
# 132 "../include/cmds.h"
case IN: {} break;
# 65 "proc.cpp" 2


        default:
            printf ("UK %d\n", *code);
            break;
    }


}


void ProcessPush (Stack* self, const char* code, int ip, Processor* Stream)
{
    int* arg = GetArg (*code, code, Stream);



    StackPush (self, *arg);
}


void ProcessPop (Stack* self, const char* code, int ip, Processor* Stream)
{
    int* arg = GetArg (*code, code, Stream);



    *arg = StackPop (self);
}


int* GetArg (int cmd, const char* code, Processor* Stream)
{


    int* arg = nullptr;

    if (cmd & ARG_IMMED) arg = (int*)(code + 1);
    if (cmd & ARG_REG) arg = Stream->Regs + *(int*)(code + 1);
    if (cmd & ARG_MEM) arg = Stream->Ram + *arg;



    return arg;
}


void ProcCtor (Processor* self)
{
    self->version = 0;
    self->cmds_amount = 0;
    self->cmds = nullptr;

    memset (self->Regs, 0, sizeof(int) * REG_AMOUNT);

    self->Ram = (int*) calloc (RAM_SIZE, sizeof (int));

}


void ProcDtor (Processor* self)
{
    self->version = 0;
    self->cmds_amount = 0;
    self->cmds = nullptr;

    memset (self->Regs, -1, sizeof(int) * REG_AMOUNT);

    FREE(self->Ram);
}
